use crate::StrError;
use crate::{Matrix, Vector};
use serde::{Deserialize, Serialize};

/// Defines the type of the interpolation grid in 1D
#[derive(Clone, Copy, Debug, Eq, PartialEq, Deserialize, Serialize)]
pub enum GridType {
    Uniform,
    ChebyshevGauss,
    ChebyshevGaussLobatto,
}

/// Implements Lagrange interpolators associated with a grid X
///
/// An interpolant I^X_N{f} (associated with a grid X; of degree N; with N+1 points)
/// is expressed in the Lagrange form as follows:
///
/// ```text
///              N
///  X          ————             X
/// I {f}(x) =  \     f(x[i]) ⋅ ℓ (x)
///  N          /                i
///             ————
///             i = 0
/// ```
///
/// where `ℓ^X_i(x)` is the i-th Lagrange cardinal polynomial associated with grid X and given by:
///
/// ```text
///          N
///  N      ━━━━    x  -  X[j]
/// ℓ (x) = ┃  ┃  —————————————
///  i      ┃  ┃   X[i] - X[j]
///        j = 0
///        j ≠ i
///
/// 0 ≤ i ≤ N
/// ```
///
/// or, barycentric form:
///
/// ```text
///              N   λ[i] ⋅ f[i]
///              Σ   ———————————
///  X          i=0   x - x[i]
/// I {f}(x) = ——————————————————
///  N            N     λ[i]
///               Σ   ————————
///              i=0  x - x[i]
/// ```
///
/// with:
///
/// ```text
///              λ[i]
///            ————————
///  N         x - x[i]
/// ℓ (x) = ———————————————
///  i        N     λ[k]
///           Σ   ————————
///          k=0  x - x[k]
/// ```
///
/// The barycentric weights `λk` are normalized and computed from `ηk` as follows:
///
/// ```text
/// ηk = Σ ln(|xk-xl|) (k≠l)
///
///       a ⋅ b             k+N
/// λk =  —————     a = (-1)
///        lf0
///
/// b = exp(m),  m = -ηk, and lf0 = 2ⁿ⁻¹/n
/// ```
///
/// or, if N > 700:
///
/// ```text
///       / a ⋅ b \   /  b  \   /  b  \
/// λk =  | ————— | ⋅ | ——— | ⋅ | ——— |
///       \  lf0  /   \ lf1 /   \ lf2 /
///
/// b = exp(m/3)  and  lf0⋅lf1⋅lf2 = 2ⁿ⁻¹/n
/// ```
///
/// # References
/// * Canuto C, Hussaini MY, Quarteroni A, Zang TA (2006) Spectral Methods: Fundamentals in
///   Single Domains. Springer. 563p
/// * Berrut JP, Trefethen LN (2004) Barycentric Lagrange Interpolation,
///   SIAM Review Vol. 46, No. 3, pp. 501-517
/// * Costa B, Don WS (2000) On the computation of high order pseudospectral derivatives,
///   Applied Numerical Mathematics, 33:151-159.
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct InterpLagrange {
    // general
    N: usize,  // degree: N = len(X)-1
    X: Vector, // grid points: len(X) = P+1; generated in [-1, 1]
    U: Vector, // function evaluated @ nodes: f(x_i)

    // barycentric
    Bary: bool,   // [default=true] use barycentric weights
    UseEta: bool, // [default=true] use ηk when computing D1
    Eta: Vector,  // sum of log of differences: ηk = Σ ln(|xk-xl|) (k≠l)
    Lam: Vector,  // normalized barycentric weights λk = pow(-1, k+N) ⋅ ηk / (2ⁿ⁻¹/n)

    // computed
    D1: Matrix, // (dℓj/dx)(xi)
    D2: Matrix, // (d²ℓj/dx²)(xi)
}

// Holds interpolators; e.g. for 2D or 3D applications
pub type InterpLagrangeSet = Vec<InterpLagrange>;

// impl InterpLagrangeSet {
//     // Allocates a new instance
//     pub fn new(ndim: usize, degrees: &[usize], grid_types: &[GridType]) -> Self {
//         let lis = vec![InterpLagrange; ndim];
//         for i in 0..ndim {
//             lis[i] = InterpLagrange::new(degrees[i], grid_types[i]);
//         }
//         lis
//     }
// }

impl InterpLagrange {
    /// Allocates a new instance
    ///
    /// # Input
    ///
    ///	* n -- degree
    /// * grid_type -- 1D grid type
    ///
    ///	**Note:** the grid will be generated in [-1, 1]
    pub fn new(N: usize, grid_type: GridType) -> Result<Self, StrError> {
        // check
        if N < 1 || N > 2048 {
            return Err("N must be in [1, 2048]");
        }

        // allocate
        let mut o = InterpLagrange {};
        o.N = N;

        // generate grid
        o.X = match grid_type {
            GridType::Uniform => Vector::linspace(-1.0, 1.0, N + 1).unwrap(),
            GridType::ChebyshevGauss => ChebyshevXgauss(N),
            GridType::ChebyshevGaussLobatto => ChebyshevXlob(N),
        };

        // barycentric data
        o.Bary = true;
        o.UseEta = true;
        o.Eta = vec![0.0; o.N + 1];
        o.Lam = vec![0.0; o.N + 1];

        // compute η
        for k in 0..self.np1 {
            for j in 0..self.np1 {
                if j != k {
                    o.Eta[k] += f64::ln(f64::abs(o.X[k] - o.X[j]));
                }
            }
        }

        // lambda factors
        let n = float64(o.N);
        if o.N > 700 {
            lf0 = math.Pow(2, n / 3.0);
            lf1 = math.Pow(2, n / 3.0);
            lf2 = math.Pow(2, n / 3.0 - 1) / n;
        } else {
            lf0 = math.Pow(2, n - 1) / n;
        }

        // compute λk
        for k in 0..self.np1 {
            let a = NegOnePowN(k + o.N);
            let m = -o.Eta[k];
            if o.N > 700 {
                let b = math.Exp(m / 3.0);
                o.Lam[k] = a * b / lf0;
                o.Lam[k] *= b / lf1;
                o.Lam[k] *= b / lf2;
            } else {
                let b = math.Exp(m);
                o.Lam[k] = a * b / lf0;
            }
            if math.IsInf(o.Lam[k], 0) {
                return Err("λk is infinite");
            }
        }
        return;
    }

    /// Computes the generating (nodal) polynomial associated with grid X
    ///
    /// The nodal polynomial is the unique polynomial of degree N+1 and
    /// leading coefficient whose zeros are the N+1 nodes of X.
    ///
    /// ```text
    ///	         N
    ///	 X      ━━━━
    ///	ω (x) = ┃  ┃ (x - X[i])
    ///	N+1     ┃  ┃
    ///	       i = 0
    /// ```
    pub fn Om(x: f64) -> f64 {
        ω = 1.0;
        for i in 0..self.np1 {
            ω *= x - o.X[i];
        }
        ω
    }

    /// Computes the i-th Lagrange cardinal polynomial associated with grid X
    ///
    /// Computes:
    ///
    /// ```text
    ///          N
    ///  X      ━━━━    x  -  X[j]
    /// ℓ (x) = ┃  ┃  —————————————
    ///  i      ┃  ┃   X[i] - X[j]
    ///        j = 0
    ///        j ≠ i
    ///
    /// 0 ≤ i ≤ N
    /// ```
    ///
    /// or (barycentric):
    ///
    /// ```text
    ///              λ[i]
    ///            ————————
    ///  X         x - x[i]
    /// ℓ (x) = ———————————————
    ///  i        N     λ[k]
    ///           Σ   ————————
    ///          k=0  x - x[k]
    /// ```
    ///
    /// # Input
    ///
    /// * `i` -- index of X[i] point
    /// * `x` -- where to evaluate the polynomial
    ///
    /// # Output
    ///
    /// Returns `ℓ^X_i(x)`
    pub fn L(i: usize, x: f64) -> f64 {
        if o.Bary {
            // barycentric formula
            if f64::abs(x - o.X[i]) < 10.0 * f64::EPSILON {
                return 1.0;
            }
            let mut sum = 0.0;
            for k in 0..self.np1 {
                sum += o.Lam[k] / (x - o.X[k]);
            }
            o.Lam[i] / (x - o.X[i]) / sum
        } else {
            // standard formula
            let mut res = 1.0;
            for j in 0..self.np1 {
                if i != j {
                    res *= (x - o.X[j]) / (o.X[i] - o.X[j]);
                }
            }
            res
        }
    }

    /// Evaluates the function f(x[i]) over all nodes
    ///
    /// The function is `(x: f64, i: usize) -> f64`
    ///
    /// # Output
    ///
    /// The results are stores in the `U` variable
    pub fn CalcU<F>(f: F)
    where
        F: FnMut(f64, usize) -> f64,
    {
        if len(o.U) != o.N + 1 {
            o.U = vec![0.0; o.N + 1];
        }
        for i in 0..self.np1 {
            let fxi = f(o.X[i]);
            o.U[i] = fxi;
        }
    }

    /// Performs the interpolation @ x
    ///
    /// Computes:
    ///
    /// ```text
    ///              N
    ///  X          ————          X
    /// I {f}(x) =  \     U[i] ⋅ ℓ (x)       with   U[i] = f(x[i])
    ///  N          /             i
    ///             ————
    ///             i = 0
    /// ```
    ///
    /// or (barycentric):
    ///
    /// ```text
    ///              N   λ[i] ⋅ f[i]
    ///              Σ   ———————————
    ///  X          i=0   x - x[i]
    /// I {f}(x) = ——————————————————
    ///  N            N     λ[i]
    ///               Σ   ————————
    ///              i=0  x - x[i]
    /// ```
    ///
    /// TODO: NOTE: U[i] = f(x[i]) must be calculated with o.CalcU or set first
    ///
    pub fn I(x: f64) -> f64 {
        if o.Bary {
            // barycentric formula
            for i in 0..self.np1 {
                dx = x - o.X[i];
                if f64::abs(dx) < 10.0 * f64::EPSILON {
                    return o.U[i];
                }
                num += o.U[i] * o.Lam[i] / dx;
                den += o.Lam[i] / dx;
            }
            num / den;
        } else {
            // standard formula
            let mut res = 0.0;
            for i in 0..self.np1 {
                res += o.U[i] * o.L(i, x);
            }
            res
        }
    }

    /// Computes the differentiation matrix D1 of the L function
    ///
    /// Computes:
    ///
    /// ```text
    ///  d I{f}(x)  |         N
    /// ——————————— |      =  Σ   D1_kj ⋅ f(x_j)
    ///      dx     |x=x_k   j=0
    /// ```
    ///
    /// See: Berrut and Trefethen (2004)
    pub fn CalcD1() {
        // allocate output
        o.D1 = Matrix::new(o.N + 1, o.N + 1);

        if o.UseEta {
            // calculate D1 using ηk
            for k in 0..self.np1 {
                let mut sumRow = 0.0;
                for j in 0..self.np1 {
                    if k != j {
                        let r = NegOnePowN(k + j) * math.Exp(o.Eta[k] - o.Eta[j]);
                        let v = r / (o.X[k] - o.X[j]);
                        o.D1.Set(k, j, v);
                        sumRow += v;
                    }
                }
                o.D1.Set(k, k, -sumRow);
            }
        } else {
            // calculate D1 using λk
            for k in 0..self.np1 {
                let mut sumRow = 0.0;
                for j in 0..self.np1 {
                    if k != j {
                        let v = (o.Lam[j] / o.Lam[k]) / (o.X[k] - o.X[j]);
                        o.D1.Set(k, j, v);
                        sumRow += v;
                    }
                }
                o.D1.Set(k, k, -sumRow);
            }
        }
    }

    /// CalcD2 calculates the second derivative of the L function
    ///
    /// ```text
    ///         d²ℓ_l  |
    /// D2_jl = —————— |
    ///          dx²   |x=x_j
    /// ```
    ///
    /// TODO NOTE: this function will call CalcD1() because the D1 values required to compute D2
    ///
    pub fn CalcD2() {
        // calculate D1
        o.CalcD1();

        // allocate output
        o.D2 = Matrix::new(o.N + 1, o.N + 1);

        // compute D2 from D1 values using Eqs. (9) and (13) of [3]
        for k in 0..self.np1 {
            let mut sumRow = 0.0;
            for j in 0..self.np1 {
                if k != j {
                    let v = 2.0 * o.D1.Get(k, j) * (o.D1.Get(k, k) - 1.0 / (o.X[k] - o.X[j]));
                    o.D2.Set(k, j, v);
                    sumRow += v;
                }
            }
            o.D2.Set(k, k, -sumRow);
        }
    }

    /// Computes the maximum error due to differentiation using the D1 matrix
    ///
    /// Computes the error @ `X[i]`
    ///
    /// # Input
    ///
    /// * `dfdxAna` -- function `(x: f64, i: usize) -> f64`
    ///
    /// NOTE: U and D1 matrix must be computed previously
    pub fn CalcErrorD1<F>(dfdxAna: F) -> f64
    where
        F: FnMut(f64, usize) -> f64,
    {
        // derivative of interpolation @ x_i
        let v = Vector::new(o.N + 1);
        la.MatVecMul(v, 1, o.D1, o.U);

        // compute error
        let mut maxDiff = 0.0;
        for i in 0..self.np1 {
            let vana = dfdxAna(o.X[i]);
            let diff = f64::abs(v[i] - vana);
            if diff > maxDiff {
                maxDiff = diff;
            }
        }
        maxDiff
    }

    /// Computes the maximum error due to differentiation using the D2 matrix
    ///
    /// Computes the error @ `X[i]`
    ///
    /// # Input
    ///
    /// * `dfdxAna` -- function `(x: f64, i: usize) -> f64`
    ///
    /// NOTE: U and D2 matrix must be computed previously
    pub fn CalcErrorD2<F>(d2fdx2Ana: F) -> f64
    where
        F: FnMut(f64, usize) -> f64,
    {
        // derivative of interpolation @ x_i
        let v = Vector::new(o.N + 1);
        la.MatVecMul(v, 1, o.D2, o.U);

        // compute error
        let mut maxDiff = 0.0;
        for i in 0..self.np1 {
            let vana = d2fdx2Ana(o.X[i]);
            let diff = f64::abs(v[i] - vana);
            if diff > maxDiff {
                maxDiff = diff;
            }
        }
        maxDiff
    }

    /// Estimates the Lebesgue constant ΛN
    ///
    /// The estimate is made with 10000 stations in `[-1, 1]`
    pub fn EstimateLebesgue() -> f64 {
        let n_station = 10000; // generate several points along [-1,1]
        let mut ΛN = 0.0;
        for j in 0..n_station {
            let x = -1.0 + 2.0 * float64(j) / float64(nsta - 1);
            let sum = f64::abs(o.L(0, x));
            for i in 1..self.np1 {
                sum += f64::abs(o.L(i, x));
            }
            if sum > ΛN {
                ΛN = sum;
            }
        }
        ΛN
    }

    /// Estimates the maximum error
    ///
    /// Computes:
    ///
    /// ```text
    /// maxerr = max(|f(x) - I{f}(x)|)
    /// ```
    ///
    /// Estimates the maximum error using n_station in `[-1,1]`
    ///
    /// # Input
    ///
    /// * `n_station` -- ≥ 2; e.g. 10000
    /// * `f` -- function `(x: f64, i: usize) -> f64`
    ///
    /// # Output
    ///
    /// Returns `(max_err, i_max)` where `i_max` is the location of the max error
    pub fn EstimateMaxErr<F>(n_station: usize, f: F) -> (f64, usize)
    where
        F: FnMut(f64, usize) -> f64,
    {
        if n_station < 2 {
            n_station = 10000;
        }
        let mut maxerr = 0.0;
        let mut xloc = 0;
        for i in 0..n_station {
            let x = -1.0 + 2.0 * float64(i) / float64(nStations - 1);
            let fx = f(x);
            let ix = o.I(x);
            let e = f64::abs(fx - ix);
            if f64::is_nan(e) {
                return Err("error is NaN\n");
            }
            if e > maxerr {
                maxerr = e;
                xloc = x;
            }
        }
        (maxerr, xloc)
    }
}
