use crate::OdeParams;
use russell_lab::Vector;

/// Holds the output of the ODE system solution
pub struct OdeOutput {
    /// Dimension of the ODE system
    ndim: usize,

    step_n_max: usize,
    dense_n_max: usize,
    step_stiffness_ratio: Vec<f64>,
    step_h: Vec<f64>,
    step_x: Vec<f64>,
    step_y: Vec<Vector>,

    dense_index_of_step: Vec<usize>,
    dense_x: Vec<f64>,
    dense_y: Vec<Vector>,

    x_out: f64,
    y_out: Vec<f64>,

    step_index: usize,
    dense_index: usize,
}

impl OdeOutput {
    pub fn new(ndim: usize, params: &OdeParams) -> OdeOutput {
        let mut o = OdeOutput {
            ndim,
            step_n_max: 0,
            dense_n_max: 0,
            step_stiffness_ratio: vec![],
            step_h: vec![],
            step_x: vec![],
            step_y: vec![],
            dense_index_of_step: vec![],
            dense_x: vec![],
            dense_y: vec![],
            y_out: vec![],
            step_index: 0,
            dense_index: 0,
            x_out: 0.0,
        };
        if params.stepOut {
            /*
            if params.fixed {
                o.step_n_max = params.fixedNsteps + 1;
            } else {
                o.step_n_max = params.NmaxSS + 1;
            }
            */
            o.step_stiffness_ratio = vec![0.0; o.step_n_max as usize];
            o.step_h = vec![0.0; o.step_n_max as usize];
            o.step_x = vec![0.0; o.step_n_max as usize];
            // o.StepY = vec![vec![0.0; ndim as usize]; o.stepNmax as usize];
        }
        if params.denseOut {
            o.dense_n_max = params.denseNstp + 1;
            o.dense_index_of_step = vec![0; o.dense_n_max as usize];
            o.dense_x = vec![0.0; o.dense_n_max as usize];
            // o.DenseY = vec![vec![0.0; ndim as usize]; o.denseNmax as usize];
        }
        if params.denseF.is_some() {
            o.y_out = vec![0.0; ndim as usize];
        }
        o
    }

    pub fn execute(&mut self, istep: usize, last: bool, rho_s: f64, h: f64, x: f64, y: &Vector) -> bool {
        // step output using function
        // if let Some(step_f) = &self.conf.stepF {
        //     let stop = step_f(istep, h, x, &y).unwrap();
        //     if stop {
        //         return true;
        //     }
        // }

        // save step output
        if self.step_index < self.step_n_max {
            self.step_stiffness_ratio[self.step_index as usize] = rho_s;
            self.step_h[self.step_index as usize] = h;
            self.step_x[self.step_index as usize] = x;
            self.step_y[self.step_index as usize] = y.clone();
            self.step_index += 1;
        }

        // dense output using function
        let mut xo: f64 = 0.0;
        // if let Some(dense_f) = &self.conf.denseF {
        //     if istep == 0 || last {
        //         xo = x;
        // self.yout = y.clone();
        // let stop = dense_f(istep, h, x, &y, xo, &self.yout).unwrap();
        // if stop {
        // return true;
        // }
        //     xo += self.conf.denseDx;
        // } else {
        //     xo = self.xout;
        //     while x >= xo {
        // self.dout(&self.yout, h, x, &y, xo);
        // let stop = dense_f(istep, h, x, &y, xo, &self.yout);
        // if stop {
        // return true;
        // }
        //             xo += self.conf.denseDx;
        //         }
        //     }
        // }

        // save dense output
        if self.dense_index < self.dense_n_max {
            if istep == 0 || last {
                xo = x;
                // self.DenseS[self.DenseIdx as usize] = istep;
                self.dense_x[self.dense_index as usize] = xo;
                self.dense_y[self.dense_index as usize] = y.clone();
                self.dense_index += 1;
                // xo = self.conf.denseDx;
            } else {
                xo = self.x_out;
                while x >= xo {
                    // self.DenseS[self.DenseIdx as usize] = istep;
                    self.dense_x[self.dense_index as usize] = xo;
                    // self.dout(&self.DenseY[self.DenseIdx as usize], h, x, &y, xo);
                    self.dense_index += 1;
                    // xo += self.conf.denseDx;
                }
            }
        }

        // set xout
        self.x_out = xo;
        false
    }

    pub fn get_step_rs(&self) -> &[f64] {
        &self.step_stiffness_ratio[..self.step_index as usize]
    }

    pub fn get_step_h(&self) -> &[f64] {
        &self.step_h[..self.step_index as usize]
    }

    pub fn get_step_x(&self) -> &[f64] {
        &self.step_x[..self.step_index as usize]
    }

    pub fn get_step_y(&self, i: usize) -> Vec<f64> {
        if self.step_index > 0 {
            self.step_y.iter().map(|y| y[i]).collect()
        } else {
            vec![]
        }
    }

    /*
    pub fn get_step_y_table(&self) -> Vec<Vec<f64>> {
        if self.StepY.is_empty() {
            vec![]
        } else {
            let ndim = self.StepY[0].len();
            self.StepY.iter().map(|y| y.clone()).collect()
        }
    }

    pub fn get_step_y_table_t(&self) -> Vec<Vec<f64>> {
        if self.StepY.is_empty() {
            vec![]
        } else {
            let ndim = self.StepY[0].len();
            (0..ndim).map(|i| self.StepY.iter().map(|y| y[i]).collect()).collect()
        }
    }
    */

    pub fn get_dense_s(&self) -> &[usize] {
        &self.dense_index_of_step[..self.dense_index as usize]
    }

    pub fn get_dense_x(&self) -> &[f64] {
        &self.dense_x[..self.dense_index as usize]
    }

    pub fn get_dense_y(&self, i: usize) -> Vec<f64> {
        if self.dense_index > 0 {
            self.dense_y.iter().map(|y| y[i]).collect()
        } else {
            vec![]
        }
    }

    /*
    pub fn get_dense_y_table(&self) -> Vec<Vec<f64>> {
        if self.DenseY.is_empty() {
            vec![]
        } else {
            let ndim = self.DenseY[0].len();
            self.DenseY.iter().map(|y| y.clone()).collect()
        }
    }

    pub fn get_dense_y_table_t(&self) -> Vec<Vec<f64>> {
        if self.DenseY.is_empty() {
            vec![]
        } else {
            let ndim = self.DenseY[0].len();
            (0..ndim).map(|i| self.DenseY.iter().map(|y| y[i]).collect()).collect()
        }
    }
    */
}
